package aero;

import java.util.ArrayList;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;

import features.Feature;
import features.PostFeature;
import features.PostInstance;



/**
 * A schematic is a group of blocks describing an island, a house, a dungeon, anything that
 * needs to be added to the map that isn't easily generated by a terrain function. AeroGen
 * generates all of its land in the form of a schematic because it's easier and cooler to
 * generate the islands individually and then spread them out in the sky than it is to use
 * a 3D noise function.
 * 
 * This class provides a simple function for keeping schematics in memory until all of the
 * chunks that they reside in have been generated. As chunks are generated, blocks are copied
 * from the schematic into the world using this classes addToChunk() method.
 * 
 * @author MortusNegati
 */
public abstract class Schematic {
	
	public static final short grass = (short) Material.GRASS.getId();
	public static final short glass = (short) Material.GLASS.getId();
	public static final short dirt = (short) Material.DIRT.getId();
	public static final short stone = (short) Material.STONE.getId();
	public static final short air = (short) Material.AIR.getId();
	public static final short snow = (short) Material.SNOW.getId();
	public static final short sand = (short) Material.SAND.getId();
	public static final short gravel = (short) Material.GRAVEL.getId();
	public static final short water = (short) 9;
	public static final short lava = (short) 11;
	public static final short reed = (short) Material.SUGAR_CANE_BLOCK.getId();
	public static final short cactus = (short) Material.CACTUS.getId();
	public static final short flowerRed = (short) Material.RED_ROSE.getId();
	public static final short flowerYellow = (short) Material.YELLOW_FLOWER.getId();
	public static final short mushroomBrown = (short) Material.BROWN_MUSHROOM.getId();
	public static final short mushroomRed = (short) Material.RED_MUSHROOM.getId();
	public static final short netherrack = (short) Material.NETHERRACK.getId();
	public static final short pumpkin = (short) Material.PUMPKIN.getId();
	public static final short watermelon = (short) Material.MELON_BLOCK.getId();
	public static final short caveSpace = air;	
	
	public static int maxSchematicChunkSize = 16;

	protected String name;
	protected Location position;
	protected Int3D size;
	protected short[] blocks;
	protected ArrayList<PostInstance> features;
	
	public Schematic(String name) {
		this.name = name;
		this.features = new ArrayList<PostInstance>();
	}
	
	public Schematic(String name, Location location, Int3D size) {
		this.name = name;
		this.position = location;
		this.size = size;		
		this.blocks = new short[size.x*size.y*size.z];
		this.features = new ArrayList<PostInstance>();
	}

	public void setBlock(int x, int y, int z, short material) {
		blocks[(x*size.z + z)*size.y + y] = material;
	}
	
	public short getBlock(int x, int y, int z) {
		return blocks[(x*size.z + z)*size.y + y];
	}

	public void setBlockSafe(int x, int y, int z, short material) {
		if(x >= 0 && x < size.x && z >= 0 && z < size.z && y >= 0 && y < size.y) {
			blocks[(x*size.z + z)*size.y + y] = material;
		}
	}
	
	public short getBlockSafe(int x, int y, int z) {
		if(x >= 0 && x < size.x && z >= 0 && z < size.z && y >= 0 && y < size.y) {
			return blocks[(x*size.z + z)*size.y + y];
		}
		return 0;
	}
	
	public int getLength() {
		return size.x;
	}

	public int getBreadth() {
		return size.z;
	}

	public int getHeight() {
		return size.y;
	}

	public short[] getBlocks() {
		return blocks;
	}
	
	public void setBlocks(short[] blocks) {
		this.blocks = blocks;
	}
	
	public int getX() {
		return floor(this.position.getX());
	}
	
	public int getY() {
		return floor(this.position.getY());
	}
	
	public int getZ() {
		return floor(this.position.getZ());
	}
	
	public String getName() {
		return this.name;
	}

	public World getWorld() {
		return this.position.getWorld();
	}
	
	public void addFeature(Feature feature, int x, int y, int z) {
		if(feature instanceof PostFeature) {
			addFeature((PostFeature) feature, x, y, z);
			return;
		}
	}
	
	public void addFeature(PostFeature feature, int x, int y, int z) {
		features.add(new PostInstance(feature, this, x, y, z));
	}

	public ArrayList<PostInstance> getFeatures() {
		return features;
	}
	
	public void addTo(Schematic scheme) {
		
	}
	
	public static int floor(double d) {
		if(d >= 0) {
			return (int) d;
		} else {
			return (int) d - 1;
		}
	}

	public Schematic asSchematic() {
		return (Schematic) this;
	}
	
}
